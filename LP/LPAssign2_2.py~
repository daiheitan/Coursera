#! /usr/bin/python
#Filename: LPAssign2_2.py

class getEL(object):
    def __init__(self, filename):
	    self.readFile(filename)
	    
    def readFile(self, filename):
	f = file(filename)
	self.outputFilename = filename.split('.')[0]+'.output'

        self.m, self.n = (int(item) for item in f.readline().split())
        self.baseV = [int(item) for item in f.readline().split()]
        self.nonbaseV = [int(item) for item in f.readline().split()]
        self.b = [float(item) for item in f.readline().split()]
        self.a = [[] for x in range(self.m)]
        for i  in range(self.m):
        	self.a[i] = [float(t) for t in f.readline().split()]
		#print i, self.a[i]
        self.objC = [float(t) for t in f.readline().split()]
	f.close()
	self.enter = self.getEnter(self.objC)
	self.leaving = self.getLeaving(self.enter)

    def getEnter(self, c):
	enter = None
	for i in range(1, self.n+1):
		if c[i]>0:
			enter = i-1
			break
	for i  in range(1, self.n+1):
		#print 'enter', enter,i
		if c[i]>0 and self.nonbaseV[i-1]<self.nonbaseV[enter]:

			enter = i-1
			#print 'e',self.nonbaseV[i-1],self.nonbaseV[enter-1] 
	return enter

    def getLeaving(self,enter):
	attr = []
	if enter == None:
		return False #final
	for i in range(self.m):
		if self.a[i][enter] >= 0:
			attr.append(-100)
		else:
			attr.append(-self.b[i]/self.a[i][enter])
	leaving = None
	for j in range(self.m):
		if attr[j]>=0:
			leaving = j
			break
	if leaving == None:
		return None # unbounded
	for j in range(0,self.m):
		if attr[j]>=0:
	            if attr[j]<attr[leaving]:
			    leaving = j
		    elif attr[j] == attr[leaving] and self.baseV[j]<self.baseV[leaving]:
			    leaving = j

	return leaving

    def getObj(self,obj):
	if self.leaving is not None:
	        newObj = obj[0]-\
		obj[self.enter+1]*self.b[self.leaving]/self.a[self.leaving][self.enter]
               # print self.nonbaseV[self.enter], self.baseV[self.leaving], newObj
	else:
		newObj = obj[0]
		print 'UNBOUNDED'
	return newObj

	
    def outputFile(self, step):
	f = file(self.outputFilename, 'w')
	if self.leaving is not None:
        	f.write(str(self.objC[0])+'\n') 
	        f.write(str(step)+'\n')
		#print 'step',step
	else: 
		f.write('UNBOUNDED')
	f.close()
    def nextDictionary(self):
	    if self.leaving == None:
		    return False
	    if self.enter == None:
		    return False
	    self.objC[0] = self.getObj(self.objC)
	    ale = self.a[self.leaving][self.enter]
	    ble = -self.b[self.leaving]/ale
	    tempAttr = []
	    attr = self.objC[self.enter+1]
	    #print ale
            for j in range(0,self.n):
		    if j == self.enter:
			    tempAttr.append(1/ale)
			    self.objC[j+1] = self.objC[j+1]/ale
		    else:
		            tempAttr.append\
			    (-self.a[self.leaving][j]/self.a[self.leaving][self.enter]) 
			    #print 'temp[j]',tempAttr[j],self.objC[j+1]
			    self.objC[j+1] += tempAttr[j]*attr
	   # print tempAttr
            for i in range(0,self.m):
		   # print 'leav, enter, ale',self.leaving, self.enter, self.a[self.leaving][self.enter]
		    if i == self.leaving:
			    self.b[i] = -self.b[i]/ale
			    for j in range(0,self.n):
				    if j == self.enter:
					    self.a[i][j] = 1/ale
				    else:
				            self.a[i][j] = -self.a[i][j]/ale
		    else:
			    self.b[i] = self.b[i]+ble*self.a[i][self.enter]
			    x = self.a[i][self.enter]
		            for j in range(0,self.n):
				    if j == self.enter:	
					    self.a[i][j] = self.a[i][j]*tempAttr[j]
				    else:
					    self.a[i][j] = self.a[i][j]+x*tempAttr[j]
	    enterV = self.nonbaseV[self.enter]
	    leavV = self.baseV[self.leaving]
	    self.nonbaseV[self.enter] = leavV
	    self.baseV[self.leaving] = enterV
	    self.enter = self.getEnter(self.objC)
	    self.leaving = self.getLeaving(self.enter)
	    	    #print self.a
	    
	    return True
    def printDict(self):
	    if self.leaving == None:
		    print 'UNBOUNDED'
            else:
	            print 'enter:',self.enter,'leaving',self.leaving
	            for i in range(self.m):
	                    print self.baseV[i],"|",self.b[i],self.a[i]
	            print self.objC
	            print self.nonbaseV






#inputFile = 'part2TestCases/assignmentParts/part4.dict'
inputFile = 'part2TestCases/assignmentParts/part1.dict' # 5 6 10

dictionary = getEL(inputFile)
i=0
while dictionary.nextDictionary():
	i+=1
dictionary.outputFile(i)
dictionary.printDict()
print i, dictionary.objC[0]

	

